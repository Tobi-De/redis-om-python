{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Object mapping, and more, for Redis and Python Redis OM Python makes it easy to model Redis data in your Python applications. Redis OM .NET | Redis OM Node.js | Redis OM Spring | Redis OM Python Table of contents span - [\ud83d\udca1 Why Redis OM?](..#-why-redis-om) - [\ud83d\udcc7 Modeling Your Data](..#-modeling-your-data) - [\u2713 Validating Data With Your Model](..#-validating-data-with-your-model) - [\ud83d\udd0e Rich Queries and Embedded Models](..#-rich-queries-and-embedded-models) - [Querying](..#querying) - [Embedded Models](..#embedded-models) - [Calling Other Redis Commands](..#calling-other-redis-commands) - [\ud83d\udcbb Installation](..#-installation) - [\ud83d\udcda Documentation](..#-documentation) - [\u26cf\ufe0f Troubleshooting](..#\ufe0f-troubleshooting) - [\u2728 So How Do You Get RediSearch and RedisJSON?](..#-so-how-do-you-get-redisearch-and-redisjson) - [\u2764\ufe0f Contributing](..#\ufe0f-contributing) - [\ud83d\udcdd License](..#-license) \ud83d\udca1 Why Redis OM? \u00b6 Redis OM provides high-level abstractions that make it easy to model and query data in Redis with modern Python applications. This preview release contains the following features: Declarative object mapping for Redis objects Declarative secondary-index generation Fluent APIs for querying Redis \ud83d\udcc7 Modeling Your Data \u00b6 Redis OM contains powerful declarative models that give you data validation, serialization, and persistence to Redis. Check out this example of modeling customer data with Redis OM. First, we create a Customer model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] Now that we have a Customer model, let's use it to save customer data to Redis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] # First, we create a new `Customer` object: andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) # The model generates a globally unique primary key automatically # without needing to talk to Redis. print ( andrew . pk ) # > \"01FJM6PH661HCNNRC884H6K30C\" # We can save the model to Redis by calling `save()`: andrew . save () # Expire the model after 2 mins (120 seconds) andrew . expire ( 120 ) # To retrieve this customer with its primary key, we use `Customer.get()`: assert Customer . get ( andrew . pk ) == andrew Ready to learn more? Check out the getting started guide. Or, continue reading to see how Redis OM makes data validation a snap. \u2713 Validating Data With Your Model \u00b6 Redis OM uses Pydantic to validate data based on the type annotations you assign to fields in a model class. This validation ensures that fields like first_name , which the Customer model marked as a str , are always strings. But every Redis OM model is also a Pydantic model , so you can use Pydantic validators like EmailStr , Pattern , and many more for complex validations! For example, because we used the EmailStr type for the email field, we'll get a validation error if we try to create a Customer with an invalid email address: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"Not an email address!\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" Any existing Pydantic validator should work as a drop-in type annotation with a Redis OM model. You can also write arbitrarily complex custom validations! To learn more, see the documentation on data validation . \ud83d\udd0e Rich Queries and Embedded Models \u00b6 Data modeling, validation, and saving models to Redis all work regardless of how you run Redis. Next, we'll show you the rich query expressions and embedded models Redis OM provides when the RediSearch and RedisJSON modules are installed in your Redis deployment, or you're using Redis Enterprise . TIP : Wait, what's a Redis module? If you aren't familiar with Redis modules, review the So, How Do You Get RediSearch and RedisJSON? section of this README. Querying \u00b6 Redis OM comes with a rich query language that allows you to query Redis with Python expressions. To show how this works, we'll make a small change to the Customer model we defined earlier. We'll add Field(index=True) to tell Redis OM that we want to index the last_name and age fields: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import ( Field , HashModel , Migrator ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) email : EmailStr join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] # Now, if we use this model with a Redis deployment that has the # RediSearch module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers with the last name \"Brookins\" Customer . find ( Customer . last_name == \"Brookins\" ) . all () # Find all customers that do NOT have the last name \"Brookins\" Customer . find ( Customer . last_name != \"Brookins\" ) . all () # Find all customers whose last name is \"Brookins\" OR whose age is # 100 AND whose last name is \"Smith\" Customer . find (( Customer . last_name == \"Brookins\" ) | ( Customer . age == 100 ) & ( Customer . last_name == \"Smith\" )) . all () These queries -- and more! -- are possible because Redis OM manages indexes for you automatically . Querying with this index features a rich expression syntax inspired by the Django ORM, SQLAlchemy, and Peewee. We think you'll enjoy it! Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator. Embedded Models \u00b6 Redis OM can store and query nested models like any document database, with the speed and power you get from Redis. Let's see how this works. In the next example, we'll define a new Address model and embed it within the Customer model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import datetime from typing import Optional from redis_om import ( EmbeddedJsonModel , JsonModel , Field , Migrator , ) class Address ( EmbeddedJsonModel ): address_line_1 : str address_line_2 : Optional [ str ] city : str = Field ( index = True ) state : str = Field ( index = True ) country : str postal_code : str = Field ( index = True ) class Customer ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) email : str = Field ( index = True ) join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] = Field ( index = True , full_text_search = True , default = \"\" ) # Creates an embedded model. address : Address # With these two models and a Redis deployment with the RedisJSON # module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers who live in San Antonio, TX Customer . find ( Customer . address . city == \"San Antonio\" , Customer . address . state == \"TX\" ) Calling Other Redis Commands \u00b6 Sometimes you'll need to run a Redis command directly. Redis OM supports this through the db method on your model's class. This returns a connected Redis client instance which exposes a function named for each Redis command. For example, let's perform some basic set operations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from redis_om import HashModel class Demo ( HashModel ): some_field : str redis_conn = Demo . db () redis_conn . sadd ( \"myset\" , \"a\" , \"b\" , \"c\" , \"d\" ) # Prints False print ( redis_conn . sismember ( \"myset\" , \"e\" )) # Prints True print ( redis_conn . sismember ( \"myset\" , \"b\" )) The parameters expected by each command function are those documented on the command's page on redis.io . If you don't want to get a Redis connection from a model class, you can also use get_redis_connection : 1 2 3 4 from redis_om import get_redis_connection redis_conn = get_redis_connection () redis_conn . set ( \"hello\" , \"world\" ) \ud83d\udcbb Installation \u00b6 Installation is simple with pip , Poetry, or Pipenv. 1 2 3 4 5 # With pip $ pip install redis-om # Or, using Poetry $ poetry add redis-om \ud83d\udcda Documentation \u00b6 The Redis OM documentation is available here . \u26cf\ufe0f Troubleshooting \u00b6 If you run into trouble or have any questions, we're here to help! Hit us up on the Redis Discord Server or open an issue on GitHub . \u2728 So How Do You Get RediSearch and RedisJSON? \u00b6 Some advanced features of Redis OM rely on core features from two source available Redis modules: RediSearch and RedisJSON . You can run these modules in your self-hosted Redis deployment, or you can use Redis Enterprise , which includes both modules. To learn more, read our documentation . \u2764\ufe0f Contributing \u00b6 We'd love your contributions! Bug reports are especially helpful at this stage of the project. You can open a bug report on GitHub . You can also contribute documentation -- or just let us know if something needs more detail. Open an issue on GitHub to get started. \ud83d\udcdd License \u00b6 Redis OM uses the MIT license .","title":"Home"},{"location":"#-why-redis-om","text":"Redis OM provides high-level abstractions that make it easy to model and query data in Redis with modern Python applications. This preview release contains the following features: Declarative object mapping for Redis objects Declarative secondary-index generation Fluent APIs for querying Redis","title":"\ud83d\udca1 Why Redis OM?"},{"location":"#-modeling-your-data","text":"Redis OM contains powerful declarative models that give you data validation, serialization, and persistence to Redis. Check out this example of modeling customer data with Redis OM. First, we create a Customer model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] Now that we have a Customer model, let's use it to save customer data to Redis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] # First, we create a new `Customer` object: andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) # The model generates a globally unique primary key automatically # without needing to talk to Redis. print ( andrew . pk ) # > \"01FJM6PH661HCNNRC884H6K30C\" # We can save the model to Redis by calling `save()`: andrew . save () # Expire the model after 2 mins (120 seconds) andrew . expire ( 120 ) # To retrieve this customer with its primary key, we use `Customer.get()`: assert Customer . get ( andrew . pk ) == andrew Ready to learn more? Check out the getting started guide. Or, continue reading to see how Redis OM makes data validation a snap.","title":"\ud83d\udcc7 Modeling Your Data"},{"location":"#-validating-data-with-your-model","text":"Redis OM uses Pydantic to validate data based on the type annotations you assign to fields in a model class. This validation ensures that fields like first_name , which the Customer model marked as a str , are always strings. But every Redis OM model is also a Pydantic model , so you can use Pydantic validators like EmailStr , Pattern , and many more for complex validations! For example, because we used the EmailStr type for the email field, we'll get a validation error if we try to create a Customer with an invalid email address: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"Not an email address!\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" Any existing Pydantic validator should work as a drop-in type annotation with a Redis OM model. You can also write arbitrarily complex custom validations! To learn more, see the documentation on data validation .","title":"\u2713 Validating Data With Your Model"},{"location":"#-rich-queries-and-embedded-models","text":"Data modeling, validation, and saving models to Redis all work regardless of how you run Redis. Next, we'll show you the rich query expressions and embedded models Redis OM provides when the RediSearch and RedisJSON modules are installed in your Redis deployment, or you're using Redis Enterprise . TIP : Wait, what's a Redis module? If you aren't familiar with Redis modules, review the So, How Do You Get RediSearch and RedisJSON? section of this README.","title":"\ud83d\udd0e Rich Queries and Embedded Models"},{"location":"#querying","text":"Redis OM comes with a rich query language that allows you to query Redis with Python expressions. To show how this works, we'll make a small change to the Customer model we defined earlier. We'll add Field(index=True) to tell Redis OM that we want to index the last_name and age fields: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import ( Field , HashModel , Migrator ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) email : EmailStr join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] # Now, if we use this model with a Redis deployment that has the # RediSearch module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers with the last name \"Brookins\" Customer . find ( Customer . last_name == \"Brookins\" ) . all () # Find all customers that do NOT have the last name \"Brookins\" Customer . find ( Customer . last_name != \"Brookins\" ) . all () # Find all customers whose last name is \"Brookins\" OR whose age is # 100 AND whose last name is \"Smith\" Customer . find (( Customer . last_name == \"Brookins\" ) | ( Customer . age == 100 ) & ( Customer . last_name == \"Smith\" )) . all () These queries -- and more! -- are possible because Redis OM manages indexes for you automatically . Querying with this index features a rich expression syntax inspired by the Django ORM, SQLAlchemy, and Peewee. We think you'll enjoy it! Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator.","title":"Querying"},{"location":"#embedded-models","text":"Redis OM can store and query nested models like any document database, with the speed and power you get from Redis. Let's see how this works. In the next example, we'll define a new Address model and embed it within the Customer model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import datetime from typing import Optional from redis_om import ( EmbeddedJsonModel , JsonModel , Field , Migrator , ) class Address ( EmbeddedJsonModel ): address_line_1 : str address_line_2 : Optional [ str ] city : str = Field ( index = True ) state : str = Field ( index = True ) country : str postal_code : str = Field ( index = True ) class Customer ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) email : str = Field ( index = True ) join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] = Field ( index = True , full_text_search = True , default = \"\" ) # Creates an embedded model. address : Address # With these two models and a Redis deployment with the RedisJSON # module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers who live in San Antonio, TX Customer . find ( Customer . address . city == \"San Antonio\" , Customer . address . state == \"TX\" )","title":"Embedded Models"},{"location":"#calling-other-redis-commands","text":"Sometimes you'll need to run a Redis command directly. Redis OM supports this through the db method on your model's class. This returns a connected Redis client instance which exposes a function named for each Redis command. For example, let's perform some basic set operations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from redis_om import HashModel class Demo ( HashModel ): some_field : str redis_conn = Demo . db () redis_conn . sadd ( \"myset\" , \"a\" , \"b\" , \"c\" , \"d\" ) # Prints False print ( redis_conn . sismember ( \"myset\" , \"e\" )) # Prints True print ( redis_conn . sismember ( \"myset\" , \"b\" )) The parameters expected by each command function are those documented on the command's page on redis.io . If you don't want to get a Redis connection from a model class, you can also use get_redis_connection : 1 2 3 4 from redis_om import get_redis_connection redis_conn = get_redis_connection () redis_conn . set ( \"hello\" , \"world\" )","title":"Calling Other Redis Commands"},{"location":"#-installation","text":"Installation is simple with pip , Poetry, or Pipenv. 1 2 3 4 5 # With pip $ pip install redis-om # Or, using Poetry $ poetry add redis-om","title":"\ud83d\udcbb Installation"},{"location":"#-documentation","text":"The Redis OM documentation is available here .","title":"\ud83d\udcda Documentation"},{"location":"#-troubleshooting","text":"If you run into trouble or have any questions, we're here to help! Hit us up on the Redis Discord Server or open an issue on GitHub .","title":"\u26cf\ufe0f Troubleshooting"},{"location":"#-so-how-do-you-get-redisearch-and-redisjson","text":"Some advanced features of Redis OM rely on core features from two source available Redis modules: RediSearch and RedisJSON . You can run these modules in your self-hosted Redis deployment, or you can use Redis Enterprise , which includes both modules. To learn more, read our documentation .","title":"\u2728 So How Do You Get RediSearch and RedisJSON?"},{"location":"#-contributing","text":"We'd love your contributions! Bug reports are especially helpful at this stage of the project. You can open a bug report on GitHub . You can also contribute documentation -- or just let us know if something needs more detail. Open an issue on GitHub to get started.","title":"\u2764\ufe0f Contributing"},{"location":"#-license","text":"Redis OM uses the MIT license .","title":"\ud83d\udcdd License"},{"location":"connections/","text":"Connecting to Redis \u00b6 You can control how Redis OM connects to Redis with the REDIS_OM_URL environment variable, or by manually constructing Redis client objects. Environment Variable \u00b6 By default, Redis OM tries to connect to Redis on your localhost at port 6379. Most local install methods will result in Redis running at this location, in which case you don't need to do anything special for Redis OM to connect to Redis. However, if you configured Redis to run on a different port, or if you're using a remote Redis server, you'll need to set the REDIS_OM_URL environment variable. The REDIS_OM_URL environment variable follows the redis-py URL format: 1 redis://[[username]:[password]]@localhost:6379/[database number] NOTE: The square brackets indicate an optional value and are not part of the URL format. The default connection is equivalent to the following REDIS_OM_URL environment variable: 1 redis://localhost:6379 Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator. Passwords and Usernames \u00b6 Redis can be configured with password protection and a \"default\" user, in which case you might connect using only the password. You can do so with Redis OM like this: 1 redis://:your-password@localhost:6379 If your Redis instance requires both a username and a password, you would include both in the URL: 1 redis://your-username:your-password@localhost:6379 Database Number \u00b6 Redis databases are numbered, and the default is 0. You can leave off the database number to use the default database, or specify it. Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator. SSL Connections \u00b6 Use the \"rediss\" prefix for SSL connections: 1 rediss://[[username]:[password]]@localhost:6379/0 Unix Domain Sockets \u00b6 Use the \"unix\" prefix to connect to Redis over Unix domain sockets: 1 unix://[[username]:[password]]@/path/to/socket.sock?db=0 To Learn More \u00b6 To learn more about the URL format that Redis OM Python uses, consult redis-py's URL documentation . TIP: The URL format is the same if you're using async or sync mode with Redis OM (i.e., importing aredis_om for async or redis_om for sync). Connection Objects \u00b6 Aside from controlling connections via the REDIS_OM_URL environment variable, you can manually construct Redis client connections for a specific OM model class. NOTE: This method takes precedence over the REDIS_OM_URL environment variable. You can control the connection a specific model class should use by assigning an object to the database field of a model's Meta object, like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 from redis_om import HashModel , get_redis_connection redis = get_redis_connection ( port = 6378 ) class Customer ( HashModel ): first_name : str last_name : str age : int class Meta : database = redis The get_redis_connection() function is a Redis OM helper that passes keyword arguments to either aioredis.Redis.from_url() or redis.Redis.from_url() , depending on whether you are using Redis OM in async or sync mode. You can also manually construct a client object: 1 2 3 4 5 6 7 8 9 10 11 12 from redis import Redis from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str age : int class Meta : database = Redis ( port = 6378 )","title":"Connections"},{"location":"connections/#connecting-to-redis","text":"You can control how Redis OM connects to Redis with the REDIS_OM_URL environment variable, or by manually constructing Redis client objects.","title":"Connecting to Redis"},{"location":"connections/#environment-variable","text":"By default, Redis OM tries to connect to Redis on your localhost at port 6379. Most local install methods will result in Redis running at this location, in which case you don't need to do anything special for Redis OM to connect to Redis. However, if you configured Redis to run on a different port, or if you're using a remote Redis server, you'll need to set the REDIS_OM_URL environment variable. The REDIS_OM_URL environment variable follows the redis-py URL format: 1 redis://[[username]:[password]]@localhost:6379/[database number] NOTE: The square brackets indicate an optional value and are not part of the URL format. The default connection is equivalent to the following REDIS_OM_URL environment variable: 1 redis://localhost:6379 Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator.","title":"Environment Variable"},{"location":"connections/#passwords-and-usernames","text":"Redis can be configured with password protection and a \"default\" user, in which case you might connect using only the password. You can do so with Redis OM like this: 1 redis://:your-password@localhost:6379 If your Redis instance requires both a username and a password, you would include both in the URL: 1 redis://your-username:your-password@localhost:6379","title":"Passwords and Usernames"},{"location":"connections/#database-number","text":"Redis databases are numbered, and the default is 0. You can leave off the database number to use the default database, or specify it. Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator.","title":"Database Number"},{"location":"connections/#ssl-connections","text":"Use the \"rediss\" prefix for SSL connections: 1 rediss://[[username]:[password]]@localhost:6379/0","title":"SSL Connections"},{"location":"connections/#unix-domain-sockets","text":"Use the \"unix\" prefix to connect to Redis over Unix domain sockets: 1 unix://[[username]:[password]]@/path/to/socket.sock?db=0","title":"Unix Domain Sockets"},{"location":"connections/#to-learn-more","text":"To learn more about the URL format that Redis OM Python uses, consult redis-py's URL documentation . TIP: The URL format is the same if you're using async or sync mode with Redis OM (i.e., importing aredis_om for async or redis_om for sync).","title":"To Learn More"},{"location":"connections/#connection-objects","text":"Aside from controlling connections via the REDIS_OM_URL environment variable, you can manually construct Redis client connections for a specific OM model class. NOTE: This method takes precedence over the REDIS_OM_URL environment variable. You can control the connection a specific model class should use by assigning an object to the database field of a model's Meta object, like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 from redis_om import HashModel , get_redis_connection redis = get_redis_connection ( port = 6378 ) class Customer ( HashModel ): first_name : str last_name : str age : int class Meta : database = redis The get_redis_connection() function is a Redis OM helper that passes keyword arguments to either aioredis.Redis.from_url() or redis.Redis.from_url() , depending on whether you are using Redis OM in async or sync mode. You can also manually construct a client object: 1 2 3 4 5 6 7 8 9 10 11 12 from redis import Redis from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str age : int class Meta : database = Redis ( port = 6378 )","title":"Connection Objects"},{"location":"errors/","text":"Errors \u00b6 This page lists errors that Redis OM might generate while you're using it, with more context about the error. E1 \u00b6 In order to query on a list field, you must define the contents of the list with a type annotation, like: orders: List[Order]. You will see this error if you try to use an \"IN\" query, e.g., await TarotWitch.find(TarotWitch.tarot_cards << \"death\").all() , on a field that is not a list. In this example, TarotWitch.tarot_cards is a list, so the query works: 1 2 3 4 5 6 from typing import List from redis_om import JsonModel , Field class TarotWitch ( JsonModel ): tarot_cards : List [ str ] = Field ( index = True ) But if tarot_cards was not a list, trying to query with << would have resulted in this error. E2 \u00b6 You tried sort by {field_name}, but {self.model} does not define that field as sortable. You tried to sort query results by a field that is not sortable. Here is how you mark a field as sortable: 1 2 3 4 5 6 from typing import List from redis_om import JsonModel , Field class Member ( JsonModel ): age : int = Field ( index = True , sortable = True ) NOTE: Only an indexed field can be sortable. E3 \u00b6 You tried to do a full-text search on the field '{field.name}', but the field is not indexed for full-text search. Use the full_text_search=True option. You can make a full-text search with the module ( % ) operator. Such a query looks like this: 1 2 3 4 5 6 from redis_om import JsonModel , Field class Member ( JsonModel ): bio : str = Field ( index = True , full_text_search = True , default = \"\" ) Member . find ( Member . bio % \"beaches\" ) . all () If you see this error, it means that the field you are querying ( bio in the example) is not indexed for full-text search. Make sure you're marking the field both index=True and full_text_search=True , as in the example. E4 \u00b6 Only lists and tuples are supported for multi-value fields. This means that you marked a field as index=True , but the field is not a type that Redis OM can actually index. Specifically, you probably used a subscripted annotation, like Dict[str, str] . The only subscripted types that OM can index are List and Tuple . E5 \u00b6 Only equals (=), not-equals (!=), and like() comparisons are supported for TEXT fields. You are querying a field you marked as indexed for full-text search. You can only query such fields with the operators for equality (==), non-equality (!=), and like (%) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from redis_om import JsonModel , Field class Member ( JsonModel ): bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Equality Member . find ( Member . bio == \"Programmer\" ) . all () # Non-equality Member . find ( Member . bio != \"Programmer\" ) . all () # Like (full-text search). This stems \"programming\" # to find any matching terms with the same stem, # \"program\". Member . find ( Member . bio % \"programming\" ) . all () E6 \u00b6 You tried to query by a field ({field_name}) that isn't indexed. You wrote a query using a model field that you did not make indexed. You can only query indexed fields. Here is example code that would generate this error: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Raises a QueryNotSupportedError because we did not make # `first_name` indexed! Member . find ( Member . first_name == \"Andrew\" ) . all () Fix this by making the field indexed: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Raises a QueryNotSupportedError because we did not make # `first_name` indexed! Member . find ( Member . first_name == \"Andrew\" ) . all () E7 \u00b6 A query expression should start with either a field or an expression enclosed in parentheses. We got confused trying to parse your query expression. It's not you, it's us! Some code examples might help... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Queries with a single operator are usually simple: Member . find ( Member . first_name == \"Andrew\" ) . all () # If you want to add multiple conditions, you can AND # them together by including the conditions one after # another as arguments. Member . find ( Member . first_name == \"Andrew\" , Member . last_name == \"Brookins\" ) . all () # Alternatively, you can separate the conditions with # parenthesis and use an explicit AND. Member . find ( ( Member . first_name == \"Andrew\" ) & ~ ( Member . last_name == \"Brookins\" ) ) . all () # You can't use `!` to say NOT. Instead, use `~`. Member . find ( ( Member . first_name == \"Andrew\" ) & ~ ( Member . last_name == \"Brookins\" ) # <- Notice, this one is NOT now! ) . all () # Parenthesis are key to building more complex queries, # like this one. Member . find ( ~ ( Member . first_name == \"Andrew\" ) & (( Member . last_name == \"Brookins\" ) | ( Member . last_name == \"Smith\" )) ) . all () # If you're confused about how Redis OM interprets a query, # use the `tree()` method to visualize the expression tree # for a `FindQuery`. query = Member . find ( ~ ( Member . first_name == \"Andrew\" ) & (( Member . last_name == \"Brookins\" ) | ( Member . last_name == \"Smith\" )) ) print ( query . expression . tree ) \"\"\" \u250cfirst_name \u250cNOT EQ\u2524 | \u2514Andrew AND\u2524 | \u250clast_name | \u250cEQ\u2524 | | \u2514Brookins \u2514OR\u2524 | \u250clast_name \u2514EQ\u2524 \u2514Smith \"\"\" E8 \u00b6 You can only combine two query expressions with AND (&) or OR (|). The only two operators you can use to combine expressions in a query are & and | . You may have accidentally used another operator, or Redis OM might be confused. Make sure you are using parentheses to organize your query expressions. If you are trying to use \"NOT,\" you can do that by prefixing a query with the ~ operator, like this: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Find people who are not named Andrew. Member . find ( ~ ( Member . first_name == \"Andrew\" )) . all () Note that this form requires parenthesis around the expression that you are \"negating.\" Of course, this example makes more sense with != : 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Find people who are not named Andrew. Member . find ( Member . first_name != \"Andrew\" ) . all () Still, ~ is useful to negate groups of expressions surrounded by parentheses.","title":"Errors"},{"location":"errors/#errors","text":"This page lists errors that Redis OM might generate while you're using it, with more context about the error.","title":"Errors"},{"location":"errors/#e1","text":"In order to query on a list field, you must define the contents of the list with a type annotation, like: orders: List[Order]. You will see this error if you try to use an \"IN\" query, e.g., await TarotWitch.find(TarotWitch.tarot_cards << \"death\").all() , on a field that is not a list. In this example, TarotWitch.tarot_cards is a list, so the query works: 1 2 3 4 5 6 from typing import List from redis_om import JsonModel , Field class TarotWitch ( JsonModel ): tarot_cards : List [ str ] = Field ( index = True ) But if tarot_cards was not a list, trying to query with << would have resulted in this error.","title":"E1"},{"location":"errors/#e2","text":"You tried sort by {field_name}, but {self.model} does not define that field as sortable. You tried to sort query results by a field that is not sortable. Here is how you mark a field as sortable: 1 2 3 4 5 6 from typing import List from redis_om import JsonModel , Field class Member ( JsonModel ): age : int = Field ( index = True , sortable = True ) NOTE: Only an indexed field can be sortable.","title":"E2"},{"location":"errors/#e3","text":"You tried to do a full-text search on the field '{field.name}', but the field is not indexed for full-text search. Use the full_text_search=True option. You can make a full-text search with the module ( % ) operator. Such a query looks like this: 1 2 3 4 5 6 from redis_om import JsonModel , Field class Member ( JsonModel ): bio : str = Field ( index = True , full_text_search = True , default = \"\" ) Member . find ( Member . bio % \"beaches\" ) . all () If you see this error, it means that the field you are querying ( bio in the example) is not indexed for full-text search. Make sure you're marking the field both index=True and full_text_search=True , as in the example.","title":"E3"},{"location":"errors/#e4","text":"Only lists and tuples are supported for multi-value fields. This means that you marked a field as index=True , but the field is not a type that Redis OM can actually index. Specifically, you probably used a subscripted annotation, like Dict[str, str] . The only subscripted types that OM can index are List and Tuple .","title":"E4"},{"location":"errors/#e5","text":"Only equals (=), not-equals (!=), and like() comparisons are supported for TEXT fields. You are querying a field you marked as indexed for full-text search. You can only query such fields with the operators for equality (==), non-equality (!=), and like (%) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from redis_om import JsonModel , Field class Member ( JsonModel ): bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Equality Member . find ( Member . bio == \"Programmer\" ) . all () # Non-equality Member . find ( Member . bio != \"Programmer\" ) . all () # Like (full-text search). This stems \"programming\" # to find any matching terms with the same stem, # \"program\". Member . find ( Member . bio % \"programming\" ) . all ()","title":"E5"},{"location":"errors/#e6","text":"You tried to query by a field ({field_name}) that isn't indexed. You wrote a query using a model field that you did not make indexed. You can only query indexed fields. Here is example code that would generate this error: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Raises a QueryNotSupportedError because we did not make # `first_name` indexed! Member . find ( Member . first_name == \"Andrew\" ) . all () Fix this by making the field indexed: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) bio : str = Field ( index = True , full_text_search = True , default = \"\" ) # Raises a QueryNotSupportedError because we did not make # `first_name` indexed! Member . find ( Member . first_name == \"Andrew\" ) . all ()","title":"E6"},{"location":"errors/#e7","text":"A query expression should start with either a field or an expression enclosed in parentheses. We got confused trying to parse your query expression. It's not you, it's us! Some code examples might help... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Queries with a single operator are usually simple: Member . find ( Member . first_name == \"Andrew\" ) . all () # If you want to add multiple conditions, you can AND # them together by including the conditions one after # another as arguments. Member . find ( Member . first_name == \"Andrew\" , Member . last_name == \"Brookins\" ) . all () # Alternatively, you can separate the conditions with # parenthesis and use an explicit AND. Member . find ( ( Member . first_name == \"Andrew\" ) & ~ ( Member . last_name == \"Brookins\" ) ) . all () # You can't use `!` to say NOT. Instead, use `~`. Member . find ( ( Member . first_name == \"Andrew\" ) & ~ ( Member . last_name == \"Brookins\" ) # <- Notice, this one is NOT now! ) . all () # Parenthesis are key to building more complex queries, # like this one. Member . find ( ~ ( Member . first_name == \"Andrew\" ) & (( Member . last_name == \"Brookins\" ) | ( Member . last_name == \"Smith\" )) ) . all () # If you're confused about how Redis OM interprets a query, # use the `tree()` method to visualize the expression tree # for a `FindQuery`. query = Member . find ( ~ ( Member . first_name == \"Andrew\" ) & (( Member . last_name == \"Brookins\" ) | ( Member . last_name == \"Smith\" )) ) print ( query . expression . tree ) \"\"\" \u250cfirst_name \u250cNOT EQ\u2524 | \u2514Andrew AND\u2524 | \u250clast_name | \u250cEQ\u2524 | | \u2514Brookins \u2514OR\u2524 | \u250clast_name \u2514EQ\u2524 \u2514Smith \"\"\"","title":"E7"},{"location":"errors/#e8","text":"You can only combine two query expressions with AND (&) or OR (|). The only two operators you can use to combine expressions in a query are & and | . You may have accidentally used another operator, or Redis OM might be confused. Make sure you are using parentheses to organize your query expressions. If you are trying to use \"NOT,\" you can do that by prefixing a query with the ~ operator, like this: 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Find people who are not named Andrew. Member . find ( ~ ( Member . first_name == \"Andrew\" )) . all () Note that this form requires parenthesis around the expression that you are \"negating.\" Of course, this example makes more sense with != : 1 2 3 4 5 6 7 8 9 from redis_om import JsonModel , Field class Member ( JsonModel ): first_name : str = Field ( index = True ) last_name : str = Field ( index = True ) # Find people who are not named Andrew. Member . find ( Member . first_name != \"Andrew\" ) . all () Still, ~ is useful to negate groups of expressions surrounded by parentheses.","title":"E8"},{"location":"fastapi_integration/","text":"FastAPI Integration \u00b6 Introduction \u00b6 Good news: Redis OM was specifically designed to integrate with FastAPI! This section includes a complete example showing how to integrate Redis OM with FastAPI. Concepts \u00b6 Every Redis OM Model is also a Pydantic model \u00b6 Every Redis OM model is also a Pydantic model, so you can define a model and then use the model class anywhere that FastAPI expects a Pydantic model. This means a couple of things: A Redis OM model can be used for request body validation Redis OM models show up in the auto-generated API documentation Cache vs. Data \u00b6 Redis works well as either a durable data store or a cache, but the optimal Redis configuration is often different between these two use cases. You almost always want to use a Redis instance tuned for caching when you're caching and a separate Redis instance tuned for data durability for storing application state. This example shows how to manage these two uses of Redis within the same application. The app uses a FastAPI caching framework and dedicated caching instance of Redis for caching, and a separate Redis instance tuned for durability for Redis OM models. Example app code \u00b6 Let's look at an example FastAPI app that uses Redis OM. NOTE : This example code requires dependencies to run. To install the dependencies, first clone the redis-om-fastapi repository from GitHub. Then follow the installation steps later in this document or in that repository's README.md file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import datetime from typing import Optional import aioredis from fastapi import FastAPI , HTTPException from starlette.requests import Request from starlette.responses import Response from fastapi_cache import FastAPICache from fastapi_cache.backends.redis import RedisBackend from fastapi_cache.decorator import cache from pydantic import EmailStr from redis_om import HashModel , NotFoundError from redis_om import get_redis_connection # This Redis instance is tuned for durability. REDIS_DATA_URL = \"redis://localhost:6380\" # This Redis instance is tuned for cache performance. REDIS_CACHE_URL = \"redis://localhost:6381\" class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] app = FastAPI () @app . post ( \"/customer\" ) async def save_customer ( customer : Customer ): # We can save the model to Redis by calling `save()`: return customer . save () @app . get ( \"/customers\" ) async def list_customers ( request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: return { \"customers\" : Customer . all_pks ()} @app . get ( \"/customer/ {pk} \" ) @cache ( expire = 10 ) async def get_customer ( pk : str , request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: try : return Customer . get ( pk ) except NotFoundError : raise HTTPException ( status_code = 404 , detail = \"Customer not found\" ) @app . on_event ( \"startup\" ) async def startup (): r = aioredis . from_url ( REDIS_CACHE_URL , encoding = \"utf8\" , decode_responses = True ) FastAPICache . init ( RedisBackend ( r ), prefix = \"fastapi-cache\" ) # You can set the Redis OM URL using the REDIS_OM_URL environment # variable, or by manually creating the connection using your model's # Meta object. Customer . Meta . database = get_redis_connection ( url = REDIS_DATA_URL , decode_responses = True ) Testing the app \u00b6 You should install the app's dependencies first. This app uses Poetry, so you'll want to make sure you have Poetry installed first: 1 $ pip install poetry Then install the dependencies: 1 $ poetry install Next, start the server: 1 $ poetry run uvicorn --reload main:app Then, in another shell, create a customer: 1 2 3 $ curl -X POST \"http://localhost:8000/customer\" -H 'Content-Type: application/json' -d '{\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"age\":\"38\",\"join_date\":\"2020 -01-02\"}' {\"pk\":\"01FM2G8EP38AVMH7PMTAJ123TA\",\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"join_date\":\"2020-01-02\",\"age\":38,\"bio\":\"\"} Get a copy of the value for \"pk,\" which is the model's primary key, and make another request to get that customer: 1 2 $ curl \"http://localhost:8000/customer/01FM2G8EP38AVMH7PMTAJ123TA\" {\"pk\":\"01FM2G8EP38AVMH7PMTAJ123TA\",\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"join_date\":\"2020-01-02\",\"age\":38,\"bio\":\"\"} You can also get a list of all customer PKs: 1 2 $ curl \"http://localhost:8000/customers\" {\"customers\":[\"01FM2G8EP38AVMH7PMTAJ123TA\"]} Redis OM with Asyncio \u00b6 Redis OM is designed to work with asyncio, so you can use Redis OM models asynchronously within FastAPI applications. The only difference is that you import the Redis OM models from the aredis_om module instead of the redis_om module. Here is the previous FastAPI app, but using asyncio-compatible Redis OM code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import datetime from typing import Optional import aioredis from fastapi import FastAPI , HTTPException from starlette.requests import Request from starlette.responses import Response from fastapi_cache import FastAPICache from fastapi_cache.backends.redis import RedisBackend from fastapi_cache.decorator import cache from pydantic import EmailStr from aredis_om import HashModel , NotFoundError # <- Notice, we import from aredis_om from aredis_om import get_redis_connection # This Redis instance is tuned for durability. REDIS_DATA_URL = \"redis://localhost:6380\" # This Redis instance is tuned for cache performance. REDIS_CACHE_URL = \"redis://localhost:6381\" class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] app = FastAPI () @app . post ( \"/customer\" ) async def save_customer ( customer : Customer ): # We can save the model to Redis by calling `save()`: return await customer . save () # <- We use await here @app . get ( \"/customers\" ) async def list_customers ( request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: return { \"customers\" : await Customer . all_pks ()} # <- We also use await here @app . get ( \"/customer/ {pk} \" ) @cache ( expire = 10 ) async def get_customer ( pk : str , request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: try : return await Customer . get ( pk ) # <- And, finally, one more await! except NotFoundError : raise HTTPException ( status_code = 404 , detail = \"Customer not found\" ) @app . on_event ( \"startup\" ) async def startup (): r = aioredis . from_url ( REDIS_CACHE_URL , encoding = \"utf8\" , decode_responses = True ) FastAPICache . init ( RedisBackend ( r ), prefix = \"fastapi-cache\" ) # You can set the Redis OM URL using the REDIS_OM_URL environment # variable, or by manually creating the connection using your model's # Meta object. Customer . Meta . database = get_redis_connection ( url = REDIS_DATA_URL , decode_responses = True ) NOTE: The modules redis_om and aredis_om are identical in almost every way. The only difference is that the aredis_om returns coroutines that you must await .","title":"Fastapi"},{"location":"fastapi_integration/#fastapi-integration","text":"","title":"FastAPI Integration"},{"location":"fastapi_integration/#introduction","text":"Good news: Redis OM was specifically designed to integrate with FastAPI! This section includes a complete example showing how to integrate Redis OM with FastAPI.","title":"Introduction"},{"location":"fastapi_integration/#concepts","text":"","title":"Concepts"},{"location":"fastapi_integration/#every-redis-om-model-is-also-a-pydantic-model","text":"Every Redis OM model is also a Pydantic model, so you can define a model and then use the model class anywhere that FastAPI expects a Pydantic model. This means a couple of things: A Redis OM model can be used for request body validation Redis OM models show up in the auto-generated API documentation","title":"Every Redis OM Model is also a Pydantic model"},{"location":"fastapi_integration/#cache-vs-data","text":"Redis works well as either a durable data store or a cache, but the optimal Redis configuration is often different between these two use cases. You almost always want to use a Redis instance tuned for caching when you're caching and a separate Redis instance tuned for data durability for storing application state. This example shows how to manage these two uses of Redis within the same application. The app uses a FastAPI caching framework and dedicated caching instance of Redis for caching, and a separate Redis instance tuned for durability for Redis OM models.","title":"Cache vs. Data"},{"location":"fastapi_integration/#example-app-code","text":"Let's look at an example FastAPI app that uses Redis OM. NOTE : This example code requires dependencies to run. To install the dependencies, first clone the redis-om-fastapi repository from GitHub. Then follow the installation steps later in this document or in that repository's README.md file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import datetime from typing import Optional import aioredis from fastapi import FastAPI , HTTPException from starlette.requests import Request from starlette.responses import Response from fastapi_cache import FastAPICache from fastapi_cache.backends.redis import RedisBackend from fastapi_cache.decorator import cache from pydantic import EmailStr from redis_om import HashModel , NotFoundError from redis_om import get_redis_connection # This Redis instance is tuned for durability. REDIS_DATA_URL = \"redis://localhost:6380\" # This Redis instance is tuned for cache performance. REDIS_CACHE_URL = \"redis://localhost:6381\" class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] app = FastAPI () @app . post ( \"/customer\" ) async def save_customer ( customer : Customer ): # We can save the model to Redis by calling `save()`: return customer . save () @app . get ( \"/customers\" ) async def list_customers ( request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: return { \"customers\" : Customer . all_pks ()} @app . get ( \"/customer/ {pk} \" ) @cache ( expire = 10 ) async def get_customer ( pk : str , request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: try : return Customer . get ( pk ) except NotFoundError : raise HTTPException ( status_code = 404 , detail = \"Customer not found\" ) @app . on_event ( \"startup\" ) async def startup (): r = aioredis . from_url ( REDIS_CACHE_URL , encoding = \"utf8\" , decode_responses = True ) FastAPICache . init ( RedisBackend ( r ), prefix = \"fastapi-cache\" ) # You can set the Redis OM URL using the REDIS_OM_URL environment # variable, or by manually creating the connection using your model's # Meta object. Customer . Meta . database = get_redis_connection ( url = REDIS_DATA_URL , decode_responses = True )","title":"Example app code"},{"location":"fastapi_integration/#testing-the-app","text":"You should install the app's dependencies first. This app uses Poetry, so you'll want to make sure you have Poetry installed first: 1 $ pip install poetry Then install the dependencies: 1 $ poetry install Next, start the server: 1 $ poetry run uvicorn --reload main:app Then, in another shell, create a customer: 1 2 3 $ curl -X POST \"http://localhost:8000/customer\" -H 'Content-Type: application/json' -d '{\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"age\":\"38\",\"join_date\":\"2020 -01-02\"}' {\"pk\":\"01FM2G8EP38AVMH7PMTAJ123TA\",\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"join_date\":\"2020-01-02\",\"age\":38,\"bio\":\"\"} Get a copy of the value for \"pk,\" which is the model's primary key, and make another request to get that customer: 1 2 $ curl \"http://localhost:8000/customer/01FM2G8EP38AVMH7PMTAJ123TA\" {\"pk\":\"01FM2G8EP38AVMH7PMTAJ123TA\",\"first_name\":\"Andrew\",\"last_name\":\"Brookins\",\"email\":\"a@example.com\",\"join_date\":\"2020-01-02\",\"age\":38,\"bio\":\"\"} You can also get a list of all customer PKs: 1 2 $ curl \"http://localhost:8000/customers\" {\"customers\":[\"01FM2G8EP38AVMH7PMTAJ123TA\"]}","title":"Testing the app"},{"location":"fastapi_integration/#redis-om-with-asyncio","text":"Redis OM is designed to work with asyncio, so you can use Redis OM models asynchronously within FastAPI applications. The only difference is that you import the Redis OM models from the aredis_om module instead of the redis_om module. Here is the previous FastAPI app, but using asyncio-compatible Redis OM code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import datetime from typing import Optional import aioredis from fastapi import FastAPI , HTTPException from starlette.requests import Request from starlette.responses import Response from fastapi_cache import FastAPICache from fastapi_cache.backends.redis import RedisBackend from fastapi_cache.decorator import cache from pydantic import EmailStr from aredis_om import HashModel , NotFoundError # <- Notice, we import from aredis_om from aredis_om import get_redis_connection # This Redis instance is tuned for durability. REDIS_DATA_URL = \"redis://localhost:6380\" # This Redis instance is tuned for cache performance. REDIS_CACHE_URL = \"redis://localhost:6381\" class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] app = FastAPI () @app . post ( \"/customer\" ) async def save_customer ( customer : Customer ): # We can save the model to Redis by calling `save()`: return await customer . save () # <- We use await here @app . get ( \"/customers\" ) async def list_customers ( request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: return { \"customers\" : await Customer . all_pks ()} # <- We also use await here @app . get ( \"/customer/ {pk} \" ) @cache ( expire = 10 ) async def get_customer ( pk : str , request : Request , response : Response ): # To retrieve this customer with its primary key, we use `Customer.get()`: try : return await Customer . get ( pk ) # <- And, finally, one more await! except NotFoundError : raise HTTPException ( status_code = 404 , detail = \"Customer not found\" ) @app . on_event ( \"startup\" ) async def startup (): r = aioredis . from_url ( REDIS_CACHE_URL , encoding = \"utf8\" , decode_responses = True ) FastAPICache . init ( RedisBackend ( r ), prefix = \"fastapi-cache\" ) # You can set the Redis OM URL using the REDIS_OM_URL environment # variable, or by manually creating the connection using your model's # Meta object. Customer . Meta . database = get_redis_connection ( url = REDIS_DATA_URL , decode_responses = True ) NOTE: The modules redis_om and aredis_om are identical in almost every way. The only difference is that the aredis_om returns coroutines that you must await .","title":"Redis OM with Asyncio"},{"location":"getting_started/","text":"Getting Started With Redis OM \u00b6 Introduction \u00b6 This tutorial will walk you through installing Redis OM, creating your first model, and using it to save and validate data. Prerequisites \u00b6 Redis OM requires Python version 3.7 or above and a Redis instance to connect to. Python \u00b6 Make sure you are running Python version 3.7 or higher : 1 2 python --version Python 3.7.0 If you don't have Python installed, you can download it from Python.org , use Pyenv , or install Python with your operating system's package manager. Redis \u00b6 Redis OM saves data in Redis, so you will need Redis installed and running to complete this tutorial. Downloading Redis \u00b6 The latest version of Redis is available from Redis.io . You can also install Redis with your operating system's package manager. NOTE: This tutorial will guide you through starting Redis locally, but the instructions will also work if Redis is running on a remote server. Installing Redis On Windows \u00b6 Redis doesn't run directly on Windows, but you can use Windows Subsystem for Linux (WSL) to run Redis. See our video on YouTube for a walk-through. Windows users can also use Docker. See the next section on running Redis with Docker for more information. Using Redis With Docker \u00b6 Instead of installing Redis manually or with a package manager, you can run Redis with Docker. We recommend the redis-stack image because it includes Redis modules that Redis OM can use to give you extra features. Later sections of this guide will provide more detail about these features. You can also use the official Redis Docker image, which is hosted on Docker Hub . However this does not include the Search and JSON modules required to store JSON models and use the find query interface. NOTE : We'll talk about how to actually start Redis with Docker when we discuss running Redis later in this guide. Recommended: RediSearch and RedisJSON \u00b6 Redis OM relies on the RediSearch and RedisJSON Redis modules to support rich queries and embedded models. You don't need these Redis modules to use Redis OM's data modeling, validation, and persistence features, but we recommend them to get the most out of Redis OM. The easiest way to run these Redis modules during local development is to use the redis-stack Docker image. For other installation methods, follow the \"Quick Start\" guides on both modules' home pages. Starting Redis \u00b6 Before you get started with Redis OM, make sure you start Redis. The command to start Redis will depend on how you installed it. Ubuntu Linux (Including WSL) \u00b6 If you installed Redis using apt , start it with the systemctl command: 1 $ sudo systemctl restart redis.service Otherwise, you can start the server manually: 1 $ redis-server start macOS with Homebrew \u00b6 1 $ brew services start redis Docker \u00b6 The command to start Redis with Docker depends on the image you've chosen to use. TIP: The -d option in these examples runs Redis in the background, while -p 6379:6379 makes Redis reachable at port 6379 on your localhost. Docker with the redismod image (recommended) \u00b6 1 $ docker run -d -p 6379:6379 redislabs/redismod Docker with the redis image \u00b6 1 $ docker run -d -p 6379:6379 redis Installing Redis OM \u00b6 The recommended way to install Redis OM is with Poetry . You can install Redis OM using Poetry with the following command: 1 $ poetry install redis-om If you're using Pipenv, the command is: 1 $ pipenv install redis-om Finally, you can install Redis OM with pip by running the following command: 1 $ pip install redis-om TIP: If you aren't using Poetry or Pipenv and are instead installing directly with pip , we recommend that you install Redis OM in a virtual environment (AKA, a virtualenv). If you aren't familiar with this concept, see Dan Bader's video and transcript . Setting the Redis URL Environment Variable \u00b6 We're almost ready to create a Redis OM model! But first, we need to make sure that Redis OM knows how to connect to Redis. By default, Redis OM tries to connect to Redis on your localhost at port 6379. Most local install methods will result in Redis running at this location, in which case you don't need to do anything special. However, if you configured Redis to run on a different port, or if you're using a remote Redis server, you'll need to set the REDIS_OM_URL environment variable. The REDIS_OM_URL environment variable follows the redis-py URL format: 1 redis://[[username]:[password]]@localhost:6379/[database number] The default connection is equivalent to the following REDIS_OM_URL environment variable: 1 redis://@localhost:6379 TIP: Redis databases are numbered, and the default is 0. You can leave off the database number to use the default database. Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator. Other supported prefixes include \"rediss\" for SSL connections and \"unix\" for Unix domain sockets: 1 2 rediss://[[username]:[password]]@localhost:6379/0 unix://[[username]:[password]]@/path/to/socket.sock?db=0 Defining a Model \u00b6 In this tutorial, we'll create a Customer model that validates and saves data. Let's start with a basic definition of the model. We'll add features as we go along. 1 2 3 4 5 6 7 8 9 10 11 12 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str There are a few details to note: Our Customer model extends the HashModel class. This means that it will be saved to Redis as a hash. The other model class that Redis OM provides is JsonModel , which we'll discuss later. We've specified the model's fields using Python type annotations. Let's dig into the HashModel class and type annotations a bit more. The HashModel Class \u00b6 When you subclass HashModel , your subclass is both a Redis OM model, with methods for saving data to Redis, and a Pydantic model. This means that you can use Pydantic field validations with your Redis OM models, which we'll cover later, when we talk about validation. But this also means you can use Redis OM models anywhere you would use a Pydantic model, like in your FastAPI applications. \ud83e\udd2f Type Annotations \u00b6 The type annotations you add to your model fields are used for a few purposes: Validating data with Pydantic validators Serializing data Redis Deserializing data from Redis We'll see examples of these throughout the course of this tutorial. An important detail about the HashModel class is that it does not support list , set , or mapping (like dict ) types. This is because Redis hashes cannot contain lists, sets, or other hashes. If you want to model fields with a list, set, or mapping type, or another model, you'll need to use the JsonModel class, which can support these types, as well as embedded models. Creating Models \u00b6 Let's see what creating a model object looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) Optional Fields \u00b6 What would happen if we left out one of these fields, like bio ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import datetime from redis_om import HashModel from pydantic import ValidationError class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str # All fields are required because none of the fields # are marked `Optional`, so we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 # <- We didn't pass in a bio! ) except ValidationError as e : print ( e ) \"\"\" ValidationError: 1 validation error for Customer bio field required (type=value_error.missing) \"\"\" If we want the bio field to be optional, we need to change the type annotation to use Optional . 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] # <- Now, bio is an Optional[str] Now we can create Customer objects with or without the bio field. Default Values \u00b6 Fields can have default values. You set them by assigning a value to a field. 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" # <- We added a default here Now, if we create a Customer object without a bio field, it will use the default value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) # <- Notice, we didn't give a bio! print ( andrew . bio ) # <- So we got the default value. # > 'Super Dope' The model will then save this default value to Redis the next time you call save() . Automatic Primary Keys \u00b6 Models generate a globally unique primary key automatically without needing to talk to Redis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) print ( andrew . pk ) # > '01FJM6PH661HCNNRC884H6K30C' The ID is available before you save the model. The default ID generation function creates ULIDs , though you can change the function that generates the primary key for models if you'd like to use a different kind of primary key. Validating Data \u00b6 Redis OM uses Pydantic to validate data based on the type annotations you assign to fields in a model class. This validation ensures that fields like first_name , which the Customer model marked as a str , are always strings. But every Redis OM model is also a Pydantic model , so you can use Pydantic validators like EmailStr , Pattern , and many more for complex validations! For example, we defined the join_date for our Customer model earlier as a datetime.date . So, if we try to create a model with a join_date that isn't a date, we'll get a validation error. Let's try it now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import datetime from typing import Optional from redis_om import HashModel from pydantic import ValidationError class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"not a date!\" , # <- The problem line! age = 38 ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer join_date invalid date format (type=value_error.date) \"\"\" Models Coerce Values By Default \u00b6 You might wonder what qualifies as a \"date\" in our last validation example. By default, Redis OM will try to coerce input values to the correct type. That means we can pass a date string for join_date instead of a date object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , # <- We're passing a YYYY-MM-DD date string now age = 38 ) print ( andrew . join_date ) # > 2021-11-02 type ( andrew . join_date ) # > datetime.date # The model parsed the string automatically! This ability to combine parsing (in this case, a YYYY-MM-DD date string) with validation can save you a lot of work. However, you can turn off coercion -- check the next section on using strict validation. Strict Validation \u00b6 You can turn on strict validation to reject values for a field unless they match the exact type of the model's type annotations. You do this by changing a field's type annotation to use one of the \"strict\" types provided by Pydantic . Redis OM supports all of Pydantic's strict types: StrictStr , StrictBytes , StrictInt , StrictFloat , and StrictBool . If we wanted to make sure that the age field only accepts integers and doesn't try to parse a string containing an integer, like \"1\", we'd use the StrictInt class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import datetime from typing import Optional from pydantic import StrictInt , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : StrictInt # <- Instead of int, we use StrictInt bio : Optional [ str ] # Now if we use a string instead of an integer for `age`, # we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , age = \"38\" # <- Age as a string shouldn't work now! ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer age Value is not a valid integer (type=type_error.integer) \"\"\" Pydantic doesn't include a StrictDate class, but we can create our own. In this example, we create a StrictDate type that we'll use to validate that join_date is a datetime.date object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import datetime from typing import Optional from pydantic import ValidationError from redis_om import HashModel class StrictDate ( datetime . date ): @classmethod def __get_validators__ ( cls ) -> 'CallableGenerator' : yield cls . validate @classmethod def validate ( cls , value : datetime . date , ** kwargs ) -> datetime . date : if not isinstance ( value , datetime . date ): raise ValueError ( \"Value must be a datetime.date object\" ) return value class Customer ( HashModel ): first_name : str last_name : str email : str join_date : StrictDate age : int bio : Optional [ str ] # Now if we use a string instead of a date object for `join_date`, # we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , # <- A string shouldn't work now! age = \"38\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer join_date Value must be a datetime.date object (type=value_error) \"\"\" Saving Models \u00b6 We can save the model to Redis by calling save() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save () Expiring Models \u00b6 We can expire an instance of a model using expire , and passing it the number of seconds after which we want the instance to expire in Redis: 1 2 # Expire Andrew in 2 minutes (120 seconds) andrew . expire ( 120 ) Examining Your Data In Redis \u00b6 You can view the data stored in Redis for any Redis OM model. First, get the key of a model instance you want to inspect. The key() method will give you the exact Redis key used to store the model. NOTE: The naming of this method may be confusing. This is not the primary key, but is instead the Redis key for this model. For this reason, the method name may change. In this example, we're looking at the key created for the Customer model we've been building: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save () andrew . key () # > 'mymodel.Customer:01FKGX1DFEV9Z2XKF59WQ6DC9T' With the model's Redis key, you can start redis-cli and inspect the data stored under that key. Here, we run JSON.GET command with redis-cli using the running \"redis\" container that this project's Docker Compose file defines: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ docker-compose exec -T redis redis-cli HGETALL mymodel.Customer:01FKGX1DFEV9Z2XKF59WQ6DC9r 1) \"pk\" 2) \"01FKGX1DFEV9Z2XKF59WQ6DC9T\" 3) \"first_name\" 4) \"Andrew\" 5) \"last_name\" 6) \"Brookins\" 7) \"email\" 8) \"andrew.brookins@example.com\" 9) \"join_date\" 10) \"2021-11-02\" 11) \"age\" 12) \"38\" 13) \"bio\" 14) \"Super dope\" Getting a Model \u00b6 If you have the primary key of a model, you can call the get() method on the model class to get the model's data. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save () assert Customer . get ( andrew . pk ) == andrew Querying for Models With Expressions \u00b6 Redis OM comes with a rich query language that allows you to query Redis with Python expressions. To show how this works, we'll make a small change to the Customer model we defined earlier. We'll add Field(index=True) to tell Redis OM that we want to index the last_name and age fields: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import ( Field , HashModel , Migrator ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) email : EmailStr join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] # Now, if we use this model with a Redis deployment that has the # RediSearch module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers with the last name \"Brookins\" Customer . find ( Customer . last_name == \"Brookins\" ) . all () # Find all customers that do NOT have the last name \"Brookins\" Customer . find ( Customer . last_name != \"Brookins\" ) . all () # Find all customers whose last name is \"Brookins\" OR whose age is # 100 AND whose last name is \"Smith\" Customer . find (( Customer . last_name == \"Brookins\" ) | ( Customer . age == 100 ) & ( Customer . last_name == \"Smith\" )) . all () Calling Other Redis Commands \u00b6 Sometimes you'll need to run a Redis command directly. Redis OM supports this through the db method on your model's class. This returns a connected Redis client instance which exposes a function named for each Redis command. For example, let's perform some basic set operations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from redis_om import HashModel class Demo ( HashModel ): some_field : str redis_conn = Demo . db () redis_conn . sadd ( \"myset\" , \"a\" , \"b\" , \"c\" , \"d\" ) # Prints False print ( redis_conn . sismember ( \"myset\" , \"e\" )) # Prints True print ( redis_conn . sismember ( \"myset\" , \"b\" )) The parameters expected by each command function are those documented on the command's page on redis.io . If you don't want to get a Redis connection from a model class, you can also use get_redis_connection : 1 2 3 4 from redis_om import get_redis_connection redis_conn = get_redis_conection () redis_conn . set ( \"hello\" , \"world\" ) Next Steps \u00b6 Now that you know the basics of working with Redis OM, start playing around with it in your project! If you're a FastAPI user, check out how to integrate Redis OM with FastAPI .","title":"Getting started"},{"location":"getting_started/#getting-started-with-redis-om","text":"","title":"Getting Started With Redis OM"},{"location":"getting_started/#introduction","text":"This tutorial will walk you through installing Redis OM, creating your first model, and using it to save and validate data.","title":"Introduction"},{"location":"getting_started/#prerequisites","text":"Redis OM requires Python version 3.7 or above and a Redis instance to connect to.","title":"Prerequisites"},{"location":"getting_started/#python","text":"Make sure you are running Python version 3.7 or higher : 1 2 python --version Python 3.7.0 If you don't have Python installed, you can download it from Python.org , use Pyenv , or install Python with your operating system's package manager.","title":"Python"},{"location":"getting_started/#redis","text":"Redis OM saves data in Redis, so you will need Redis installed and running to complete this tutorial.","title":"Redis"},{"location":"getting_started/#downloading-redis","text":"The latest version of Redis is available from Redis.io . You can also install Redis with your operating system's package manager. NOTE: This tutorial will guide you through starting Redis locally, but the instructions will also work if Redis is running on a remote server.","title":"Downloading Redis"},{"location":"getting_started/#installing-redis-on-windows","text":"Redis doesn't run directly on Windows, but you can use Windows Subsystem for Linux (WSL) to run Redis. See our video on YouTube for a walk-through. Windows users can also use Docker. See the next section on running Redis with Docker for more information.","title":"Installing Redis On Windows"},{"location":"getting_started/#using-redis-with-docker","text":"Instead of installing Redis manually or with a package manager, you can run Redis with Docker. We recommend the redis-stack image because it includes Redis modules that Redis OM can use to give you extra features. Later sections of this guide will provide more detail about these features. You can also use the official Redis Docker image, which is hosted on Docker Hub . However this does not include the Search and JSON modules required to store JSON models and use the find query interface. NOTE : We'll talk about how to actually start Redis with Docker when we discuss running Redis later in this guide.","title":"Using Redis With Docker"},{"location":"getting_started/#recommended-redisearch-and-redisjson","text":"Redis OM relies on the RediSearch and RedisJSON Redis modules to support rich queries and embedded models. You don't need these Redis modules to use Redis OM's data modeling, validation, and persistence features, but we recommend them to get the most out of Redis OM. The easiest way to run these Redis modules during local development is to use the redis-stack Docker image. For other installation methods, follow the \"Quick Start\" guides on both modules' home pages.","title":"Recommended: RediSearch and RedisJSON"},{"location":"getting_started/#starting-redis","text":"Before you get started with Redis OM, make sure you start Redis. The command to start Redis will depend on how you installed it.","title":"Starting Redis"},{"location":"getting_started/#ubuntu-linux-including-wsl","text":"If you installed Redis using apt , start it with the systemctl command: 1 $ sudo systemctl restart redis.service Otherwise, you can start the server manually: 1 $ redis-server start","title":"Ubuntu Linux (Including WSL)"},{"location":"getting_started/#macos-with-homebrew","text":"1 $ brew services start redis","title":"macOS with Homebrew"},{"location":"getting_started/#docker","text":"The command to start Redis with Docker depends on the image you've chosen to use. TIP: The -d option in these examples runs Redis in the background, while -p 6379:6379 makes Redis reachable at port 6379 on your localhost.","title":"Docker"},{"location":"getting_started/#docker-with-the-redismod-image-recommended","text":"1 $ docker run -d -p 6379:6379 redislabs/redismod","title":"Docker with the redismod image (recommended)"},{"location":"getting_started/#docker-with-the-redis-image","text":"1 $ docker run -d -p 6379:6379 redis","title":"Docker with the redis image"},{"location":"getting_started/#installing-redis-om","text":"The recommended way to install Redis OM is with Poetry . You can install Redis OM using Poetry with the following command: 1 $ poetry install redis-om If you're using Pipenv, the command is: 1 $ pipenv install redis-om Finally, you can install Redis OM with pip by running the following command: 1 $ pip install redis-om TIP: If you aren't using Poetry or Pipenv and are instead installing directly with pip , we recommend that you install Redis OM in a virtual environment (AKA, a virtualenv). If you aren't familiar with this concept, see Dan Bader's video and transcript .","title":"Installing Redis OM"},{"location":"getting_started/#setting-the-redis-url-environment-variable","text":"We're almost ready to create a Redis OM model! But first, we need to make sure that Redis OM knows how to connect to Redis. By default, Redis OM tries to connect to Redis on your localhost at port 6379. Most local install methods will result in Redis running at this location, in which case you don't need to do anything special. However, if you configured Redis to run on a different port, or if you're using a remote Redis server, you'll need to set the REDIS_OM_URL environment variable. The REDIS_OM_URL environment variable follows the redis-py URL format: 1 redis://[[username]:[password]]@localhost:6379/[database number] The default connection is equivalent to the following REDIS_OM_URL environment variable: 1 redis://@localhost:6379 TIP: Redis databases are numbered, and the default is 0. You can leave off the database number to use the default database. Note: Indexing only works for data stored in Redis logical database 0. If you are using a different database number when connecting to Redis, you can expect the code to raise a MigrationError when you run the migrator. Other supported prefixes include \"rediss\" for SSL connections and \"unix\" for Unix domain sockets: 1 2 rediss://[[username]:[password]]@localhost:6379/0 unix://[[username]:[password]]@/path/to/socket.sock?db=0","title":"Setting the Redis URL Environment Variable"},{"location":"getting_started/#defining-a-model","text":"In this tutorial, we'll create a Customer model that validates and saves data. Let's start with a basic definition of the model. We'll add features as we go along. 1 2 3 4 5 6 7 8 9 10 11 12 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str There are a few details to note: Our Customer model extends the HashModel class. This means that it will be saved to Redis as a hash. The other model class that Redis OM provides is JsonModel , which we'll discuss later. We've specified the model's fields using Python type annotations. Let's dig into the HashModel class and type annotations a bit more.","title":"Defining a Model"},{"location":"getting_started/#the-hashmodel-class","text":"When you subclass HashModel , your subclass is both a Redis OM model, with methods for saving data to Redis, and a Pydantic model. This means that you can use Pydantic field validations with your Redis OM models, which we'll cover later, when we talk about validation. But this also means you can use Redis OM models anywhere you would use a Pydantic model, like in your FastAPI applications. \ud83e\udd2f","title":"The HashModel Class"},{"location":"getting_started/#type-annotations","text":"The type annotations you add to your model fields are used for a few purposes: Validating data with Pydantic validators Serializing data Redis Deserializing data from Redis We'll see examples of these throughout the course of this tutorial. An important detail about the HashModel class is that it does not support list , set , or mapping (like dict ) types. This is because Redis hashes cannot contain lists, sets, or other hashes. If you want to model fields with a list, set, or mapping type, or another model, you'll need to use the JsonModel class, which can support these types, as well as embedded models.","title":"Type Annotations"},{"location":"getting_started/#creating-models","text":"Let's see what creating a model object looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" )","title":"Creating Models"},{"location":"getting_started/#optional-fields","text":"What would happen if we left out one of these fields, like bio ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import datetime from redis_om import HashModel from pydantic import ValidationError class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : str # All fields are required because none of the fields # are marked `Optional`, so we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 # <- We didn't pass in a bio! ) except ValidationError as e : print ( e ) \"\"\" ValidationError: 1 validation error for Customer bio field required (type=value_error.missing) \"\"\" If we want the bio field to be optional, we need to change the type annotation to use Optional . 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] # <- Now, bio is an Optional[str] Now we can create Customer objects with or without the bio field.","title":"Optional Fields"},{"location":"getting_started/#default-values","text":"Fields can have default values. You set them by assigning a value to a field. 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" # <- We added a default here Now, if we create a Customer object without a bio field, it will use the default value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) # <- Notice, we didn't give a bio! print ( andrew . bio ) # <- So we got the default value. # > 'Super Dope' The model will then save this default value to Redis the next time you call save() .","title":"Default Values"},{"location":"getting_started/#automatic-primary-keys","text":"Models generate a globally unique primary key automatically without needing to talk to Redis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) print ( andrew . pk ) # > '01FJM6PH661HCNNRC884H6K30C' The ID is available before you save the model. The default ID generation function creates ULIDs , though you can change the function that generates the primary key for models if you'd like to use a different kind of primary key.","title":"Automatic Primary Keys"},{"location":"getting_started/#validating-data","text":"Redis OM uses Pydantic to validate data based on the type annotations you assign to fields in a model class. This validation ensures that fields like first_name , which the Customer model marked as a str , are always strings. But every Redis OM model is also a Pydantic model , so you can use Pydantic validators like EmailStr , Pattern , and many more for complex validations! For example, we defined the join_date for our Customer model earlier as a datetime.date . So, if we try to create a model with a join_date that isn't a date, we'll get a validation error. Let's try it now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import datetime from typing import Optional from redis_om import HashModel from pydantic import ValidationError class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"not a date!\" , # <- The problem line! age = 38 ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer join_date invalid date format (type=value_error.date) \"\"\"","title":"Validating Data"},{"location":"getting_started/#models-coerce-values-by-default","text":"You might wonder what qualifies as a \"date\" in our last validation example. By default, Redis OM will try to coerce input values to the correct type. That means we can pass a date string for join_date instead of a date object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , # <- We're passing a YYYY-MM-DD date string now age = 38 ) print ( andrew . join_date ) # > 2021-11-02 type ( andrew . join_date ) # > datetime.date # The model parsed the string automatically! This ability to combine parsing (in this case, a YYYY-MM-DD date string) with validation can save you a lot of work. However, you can turn off coercion -- check the next section on using strict validation.","title":"Models Coerce Values By Default"},{"location":"getting_started/#strict-validation","text":"You can turn on strict validation to reject values for a field unless they match the exact type of the model's type annotations. You do this by changing a field's type annotation to use one of the \"strict\" types provided by Pydantic . Redis OM supports all of Pydantic's strict types: StrictStr , StrictBytes , StrictInt , StrictFloat , and StrictBool . If we wanted to make sure that the age field only accepts integers and doesn't try to parse a string containing an integer, like \"1\", we'd use the StrictInt class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import datetime from typing import Optional from pydantic import StrictInt , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : StrictInt # <- Instead of int, we use StrictInt bio : Optional [ str ] # Now if we use a string instead of an integer for `age`, # we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , age = \"38\" # <- Age as a string shouldn't work now! ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer age Value is not a valid integer (type=type_error.integer) \"\"\" Pydantic doesn't include a StrictDate class, but we can create our own. In this example, we create a StrictDate type that we'll use to validate that join_date is a datetime.date object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import datetime from typing import Optional from pydantic import ValidationError from redis_om import HashModel class StrictDate ( datetime . date ): @classmethod def __get_validators__ ( cls ) -> 'CallableGenerator' : yield cls . validate @classmethod def validate ( cls , value : datetime . date , ** kwargs ) -> datetime . date : if not isinstance ( value , datetime . date ): raise ValueError ( \"Value must be a datetime.date object\" ) return value class Customer ( HashModel ): first_name : str last_name : str email : str join_date : StrictDate age : int bio : Optional [ str ] # Now if we use a string instead of a date object for `join_date`, # we get a validation error: try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"a@example.com\" , join_date = \"2020-01-02\" , # <- A string shouldn't work now! age = \"38\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer join_date Value must be a datetime.date object (type=value_error) \"\"\"","title":"Strict Validation"},{"location":"getting_started/#saving-models","text":"We can save the model to Redis by calling save() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save ()","title":"Saving Models"},{"location":"getting_started/#expiring-models","text":"We can expire an instance of a model using expire , and passing it the number of seconds after which we want the instance to expire in Redis: 1 2 # Expire Andrew in 2 minutes (120 seconds) andrew . expire ( 120 )","title":"Expiring Models"},{"location":"getting_started/#examining-your-data-in-redis","text":"You can view the data stored in Redis for any Redis OM model. First, get the key of a model instance you want to inspect. The key() method will give you the exact Redis key used to store the model. NOTE: The naming of this method may be confusing. This is not the primary key, but is instead the Redis key for this model. For this reason, the method name may change. In this example, we're looking at the key created for the Customer model we've been building: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save () andrew . key () # > 'mymodel.Customer:01FKGX1DFEV9Z2XKF59WQ6DC9T' With the model's Redis key, you can start redis-cli and inspect the data stored under that key. Here, we run JSON.GET command with redis-cli using the running \"redis\" container that this project's Docker Compose file defines: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ docker-compose exec -T redis redis-cli HGETALL mymodel.Customer:01FKGX1DFEV9Z2XKF59WQ6DC9r 1) \"pk\" 2) \"01FKGX1DFEV9Z2XKF59WQ6DC9T\" 3) \"first_name\" 4) \"Andrew\" 5) \"last_name\" 6) \"Brookins\" 7) \"email\" 8) \"andrew.brookins@example.com\" 9) \"join_date\" 10) \"2021-11-02\" 11) \"age\" 12) \"38\" 13) \"bio\" 14) \"Super dope\"","title":"Examining Your Data In Redis"},{"location":"getting_started/#getting-a-model","text":"If you have the primary key of a model, you can call the get() method on the model class to get the model's data. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) andrew . save () assert Customer . get ( andrew . pk ) == andrew","title":"Getting a Model"},{"location":"getting_started/#querying-for-models-with-expressions","text":"Redis OM comes with a rich query language that allows you to query Redis with Python expressions. To show how this works, we'll make a small change to the Customer model we defined earlier. We'll add Field(index=True) to tell Redis OM that we want to index the last_name and age fields: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import datetime from typing import Optional from pydantic import EmailStr from redis_om import ( Field , HashModel , Migrator ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) email : EmailStr join_date : datetime . date age : int = Field ( index = True ) bio : Optional [ str ] # Now, if we use this model with a Redis deployment that has the # RediSearch module installed, we can run queries like the following. # Before running queries, we need to run migrations to set up the # indexes that Redis OM will use. You can also use the `migrate` # CLI tool for this! Migrator () . run () # Find all customers with the last name \"Brookins\" Customer . find ( Customer . last_name == \"Brookins\" ) . all () # Find all customers that do NOT have the last name \"Brookins\" Customer . find ( Customer . last_name != \"Brookins\" ) . all () # Find all customers whose last name is \"Brookins\" OR whose age is # 100 AND whose last name is \"Smith\" Customer . find (( Customer . last_name == \"Brookins\" ) | ( Customer . age == 100 ) & ( Customer . last_name == \"Smith\" )) . all ()","title":"Querying for Models With Expressions"},{"location":"getting_started/#calling-other-redis-commands","text":"Sometimes you'll need to run a Redis command directly. Redis OM supports this through the db method on your model's class. This returns a connected Redis client instance which exposes a function named for each Redis command. For example, let's perform some basic set operations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from redis_om import HashModel class Demo ( HashModel ): some_field : str redis_conn = Demo . db () redis_conn . sadd ( \"myset\" , \"a\" , \"b\" , \"c\" , \"d\" ) # Prints False print ( redis_conn . sismember ( \"myset\" , \"e\" )) # Prints True print ( redis_conn . sismember ( \"myset\" , \"b\" )) The parameters expected by each command function are those documented on the command's page on redis.io . If you don't want to get a Redis connection from a model class, you can also use get_redis_connection : 1 2 3 4 from redis_om import get_redis_connection redis_conn = get_redis_conection () redis_conn . set ( \"hello\" , \"world\" )","title":"Calling Other Redis Commands"},{"location":"getting_started/#next-steps","text":"Now that you know the basics of working with Redis OM, start playing around with it in your project! If you're a FastAPI user, check out how to integrate Redis OM with FastAPI .","title":"Next Steps"},{"location":"models/","text":"Models and Fields \u00b6 The heart of Redis OM's object mapping, validation, and querying features is a pair of declarative models: HashModel and JsonModel . Both models work provide roughly the same API, but they store data in Redis differently. This page will explain how to create your Redis OM model by subclassing one of these classes. HashModel vs. JsonModel \u00b6 First, which should you use? The choice is relatively simple. If you want to embed a model inside another model, like giving a Customer model a list of Order models, then you need to use JsonModel . Only JsonModel supports embedded models. Otherwise, use HashModel . Creating Your Model \u00b6 You create a Redis OM model by subclassing HashModel or JsonModel . For example: 1 2 3 4 5 6 from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str Configuring Models \u00b6 There are several Redis OM-specific settings you can configure in models. You configure these settings using a special object called the Meta object . Here is an example of using the Meta object to set a global key prefix: 1 2 3 4 5 6 7 8 9 from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str class Meta : global_key_prefix = \"customer-dashboard\" Abstract Models \u00b6 You can create abstract Redis OM models by subclassing ABC in addition to either HashModel or JsonModel . Abstract models exist only to gather shared configuration for subclasses -- you can't instantiate them. One use of abstract models is to configure a Redis key prefix that all models in your application will use. This is a good best practice with Redis. Here's how you'd do it with an abstract model: 1 2 3 4 5 6 7 8 from abc import ABC from redis_om import HashModel class BaseModel ( HashModel , ABC ): class Meta : global_key_prefix = \"your-application\" The Meta Object Is \"Special\" \u00b6 The Meta object has a special property: if you create a model subclass from a base class that has a Meta object, Redis OM copies the parent's fields into the Meta object in the child class. Because of this, a subclass can override a single field in its parent's Meta class without having to redefine all fields. An example will make this clearer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from abc import ABC from redis_om import HashModel , get_redis_connection redis = get_redis_connection ( port = 6380 ) other_redis = get_redis_connection ( port = 6381 ) class BaseModel ( HashModel , ABC ): class Meta : global_key_prefix = \"customer-dashboard\" database = redis class Customer ( BaseModel ): first_name : str last_name : str class Meta : database = other_redis print ( Customer . global_key_prefix ) # > \"customer-dashboard\" In this example, we created an abstract base model called BaseModel and gave it a Meta object containing a database connection and a global key prefix. Then we created a subclass BaseModel called Customer and gave it a second Meta object, but only defined database . Customer also gets the global key prefix that BaseModel defined (\"customer-dashboard\"). While this is not how object inheritance usually works in Python, we think it is helpful to make abstract models more useful, especially as a way to group shared model settings. All Settings Supported by the Meta Object \u00b6 Here is a table of the settings available in the Meta object and what they control. Setting Description Default global_key_prefix A string prefix applied to every Redis key that the model manages. This could be something like your application's name. \"\" model_key_prefix A string prefix applied to the Redis key representing every model. For example, the Redis Hash key for a HashModel. This prefix is also added to the redisearch index created for every model with indexed fields. \"\" primary_key_pattern A format string producing the base string for a Redis key representing this model. This string should accept a \"pk\" format argument. Note: This is a \"new style\" format string, which will be called with .format() . \"{pk}\" database An aioredis.Redis or redis.Redis client instance that the model will use to communicate with Redis. A new instance created with connections.get_redis_connection(). primary_key_creator_cls A class that adheres to the PrimaryKeyCreator protocol, which Redis OM will use to create a primary key for a new model instance. UlidPrimaryKey index_name The RediSearch index name to use for this model. Only used if at least one of the model's fields are marked as indexable ( index=True ). \"{global_key_prefix}:{model_key_prefix}:index\" embedded Whether or not this model is \"embedded.\" Embedded models are not included in migrations that create and destroy indexes. Instead, their indexed fields are included in the index for the parent model. Note : Only JsonModel can have embedded models. False encoding The default encoding to use for strings. This encoding is given to redis-py or aioredis at the connection level. In both cases, Redis OM will decode binary strings from Redis using your chosen encoding. \"utf-8\" ## Configuring Pydantic Every Redis OM model is also a Pydantic model, so in addition to configuring Redis OM behavior with the Meta object, you can control Pydantic configuration via the Config object within a model class. See the Pydantic documentation for details on how this object works and the settings that are available. The default Pydantic configuration for models, which Redis OM sets for you, is equivalent to the following (demonstrated on an actual model): 1 2 3 4 5 6 7 8 9 10 from redis_om import HashModel class Customer ( HashModel ): # ... Fields ... class Config : orm_mode = True arbitrary_types_allowed = True extra = \"allow\" Some features may not work correctly if you change these settings. Fields \u00b6 You define fields on a Redis OM model using Python type annotations . If you aren't familiar with type annotations, check out this tutorial . This works exactly the same way as it does with Pydantic. Check out the Pydantic documentation on field types for guidance. With HashModel \u00b6 HashModel stores data in Redis Hashes, which are flat. This means that a Redis Hash can't contain a Redis Set, List, or Hash. Because of this requirement, HashModel also does not currently support container types, such as: Sets Lists Dictionaries and other \"mapping\" types Other Redis OM models Pydantic models NOTE : In the future, we may serialize these values as JSON strings, the same way we do for JsonModel . The difference would be that in the case of HashModel , you wouldn't be able to index these fields, just get and save them with the model. With JsonModel , you can index list fields and embedded JsonModel s. So, in short, if you want to use container types, use JsonModel . With JsonModel \u00b6 Good news! Container types are supported with JsonModel . We will use Pydantic's JSON serialization and encoding to serialize your JsonModel and save it in Redis. Default Values \u00b6 Fields can have default values. You set them by assigning a value to a field. 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" # <- We added a default here Now, if we create a Customer object without a bio field, it will use the default value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) # <- Notice, we didn't give a bio! print ( andrew . bio ) # <- So we got the default value. # > 'Super Dope' The model will then save this default value to Redis the next time you call save() . Marking a Field as Indexed \u00b6 If you're using the RediSearch module in your Redis instance, you can mark a field as \"indexed.\" As soon as you mark any field in a model as indexed, Redis OM will automatically create and manage an secondary index for the model for you, allowing you to query on any indexed field. To mark a field as indexed, you need to use the Redis OM Field() helper, like this: 1 2 3 4 5 6 7 8 9 from redis_om import ( Field , HashModel , ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) In this example, we marked Customer.last_name as indexed. To create the indexes for any models that have indexed fields, use the migrate CLI command that Redis OM installs in your Python environment. This command detects any JsonModel or HashModel instances in your project and does the following for each model that isn't abstract or embedded: If no index exists yet for the model: The migrator creates an index The migrator stores a hash of the index definition If an index exists for the model: The migrator checks if the stored hash for the index is out of date If the stored hash is out of date, the migrator drops the index (not your data!) and rebuilds it with the new index definition You can also run the Migrator yourself with code: 1 2 3 4 5 6 7 from redis_om import ( get_redis_connection , Migrator ) redis = get_redis_connection () Migrator () . run ()","title":"Models"},{"location":"models/#models-and-fields","text":"The heart of Redis OM's object mapping, validation, and querying features is a pair of declarative models: HashModel and JsonModel . Both models work provide roughly the same API, but they store data in Redis differently. This page will explain how to create your Redis OM model by subclassing one of these classes.","title":"Models and Fields"},{"location":"models/#hashmodel-vs-jsonmodel","text":"First, which should you use? The choice is relatively simple. If you want to embed a model inside another model, like giving a Customer model a list of Order models, then you need to use JsonModel . Only JsonModel supports embedded models. Otherwise, use HashModel .","title":"HashModel vs. JsonModel"},{"location":"models/#creating-your-model","text":"You create a Redis OM model by subclassing HashModel or JsonModel . For example: 1 2 3 4 5 6 from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str","title":"Creating Your Model"},{"location":"models/#configuring-models","text":"There are several Redis OM-specific settings you can configure in models. You configure these settings using a special object called the Meta object . Here is an example of using the Meta object to set a global key prefix: 1 2 3 4 5 6 7 8 9 from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str class Meta : global_key_prefix = \"customer-dashboard\"","title":"Configuring Models"},{"location":"models/#abstract-models","text":"You can create abstract Redis OM models by subclassing ABC in addition to either HashModel or JsonModel . Abstract models exist only to gather shared configuration for subclasses -- you can't instantiate them. One use of abstract models is to configure a Redis key prefix that all models in your application will use. This is a good best practice with Redis. Here's how you'd do it with an abstract model: 1 2 3 4 5 6 7 8 from abc import ABC from redis_om import HashModel class BaseModel ( HashModel , ABC ): class Meta : global_key_prefix = \"your-application\"","title":"Abstract Models"},{"location":"models/#the-meta-object-is-special","text":"The Meta object has a special property: if you create a model subclass from a base class that has a Meta object, Redis OM copies the parent's fields into the Meta object in the child class. Because of this, a subclass can override a single field in its parent's Meta class without having to redefine all fields. An example will make this clearer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from abc import ABC from redis_om import HashModel , get_redis_connection redis = get_redis_connection ( port = 6380 ) other_redis = get_redis_connection ( port = 6381 ) class BaseModel ( HashModel , ABC ): class Meta : global_key_prefix = \"customer-dashboard\" database = redis class Customer ( BaseModel ): first_name : str last_name : str class Meta : database = other_redis print ( Customer . global_key_prefix ) # > \"customer-dashboard\" In this example, we created an abstract base model called BaseModel and gave it a Meta object containing a database connection and a global key prefix. Then we created a subclass BaseModel called Customer and gave it a second Meta object, but only defined database . Customer also gets the global key prefix that BaseModel defined (\"customer-dashboard\"). While this is not how object inheritance usually works in Python, we think it is helpful to make abstract models more useful, especially as a way to group shared model settings.","title":"The Meta Object Is \"Special\""},{"location":"models/#all-settings-supported-by-the-meta-object","text":"Here is a table of the settings available in the Meta object and what they control. Setting Description Default global_key_prefix A string prefix applied to every Redis key that the model manages. This could be something like your application's name. \"\" model_key_prefix A string prefix applied to the Redis key representing every model. For example, the Redis Hash key for a HashModel. This prefix is also added to the redisearch index created for every model with indexed fields. \"\" primary_key_pattern A format string producing the base string for a Redis key representing this model. This string should accept a \"pk\" format argument. Note: This is a \"new style\" format string, which will be called with .format() . \"{pk}\" database An aioredis.Redis or redis.Redis client instance that the model will use to communicate with Redis. A new instance created with connections.get_redis_connection(). primary_key_creator_cls A class that adheres to the PrimaryKeyCreator protocol, which Redis OM will use to create a primary key for a new model instance. UlidPrimaryKey index_name The RediSearch index name to use for this model. Only used if at least one of the model's fields are marked as indexable ( index=True ). \"{global_key_prefix}:{model_key_prefix}:index\" embedded Whether or not this model is \"embedded.\" Embedded models are not included in migrations that create and destroy indexes. Instead, their indexed fields are included in the index for the parent model. Note : Only JsonModel can have embedded models. False encoding The default encoding to use for strings. This encoding is given to redis-py or aioredis at the connection level. In both cases, Redis OM will decode binary strings from Redis using your chosen encoding. \"utf-8\" ## Configuring Pydantic Every Redis OM model is also a Pydantic model, so in addition to configuring Redis OM behavior with the Meta object, you can control Pydantic configuration via the Config object within a model class. See the Pydantic documentation for details on how this object works and the settings that are available. The default Pydantic configuration for models, which Redis OM sets for you, is equivalent to the following (demonstrated on an actual model): 1 2 3 4 5 6 7 8 9 10 from redis_om import HashModel class Customer ( HashModel ): # ... Fields ... class Config : orm_mode = True arbitrary_types_allowed = True extra = \"allow\" Some features may not work correctly if you change these settings.","title":"All Settings Supported by the Meta Object"},{"location":"models/#fields","text":"You define fields on a Redis OM model using Python type annotations . If you aren't familiar with type annotations, check out this tutorial . This works exactly the same way as it does with Pydantic. Check out the Pydantic documentation on field types for guidance.","title":"Fields"},{"location":"models/#with-hashmodel","text":"HashModel stores data in Redis Hashes, which are flat. This means that a Redis Hash can't contain a Redis Set, List, or Hash. Because of this requirement, HashModel also does not currently support container types, such as: Sets Lists Dictionaries and other \"mapping\" types Other Redis OM models Pydantic models NOTE : In the future, we may serialize these values as JSON strings, the same way we do for JsonModel . The difference would be that in the case of HashModel , you wouldn't be able to index these fields, just get and save them with the model. With JsonModel , you can index list fields and embedded JsonModel s. So, in short, if you want to use container types, use JsonModel .","title":"With HashModel"},{"location":"models/#with-jsonmodel","text":"Good news! Container types are supported with JsonModel . We will use Pydantic's JSON serialization and encoding to serialize your JsonModel and save it in Redis.","title":"With JsonModel"},{"location":"models/#default-values","text":"Fields can have default values. You set them by assigning a value to a field. 1 2 3 4 5 6 7 8 9 10 11 12 13 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" # <- We added a default here Now, if we create a Customer object without a bio field, it will use the default value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import datetime from typing import Optional from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : str join_date : datetime . date age : int bio : Optional [ str ] = \"Super dope\" andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 ) # <- Notice, we didn't give a bio! print ( andrew . bio ) # <- So we got the default value. # > 'Super Dope' The model will then save this default value to Redis the next time you call save() .","title":"Default Values"},{"location":"models/#marking-a-field-as-indexed","text":"If you're using the RediSearch module in your Redis instance, you can mark a field as \"indexed.\" As soon as you mark any field in a model as indexed, Redis OM will automatically create and manage an secondary index for the model for you, allowing you to query on any indexed field. To mark a field as indexed, you need to use the Redis OM Field() helper, like this: 1 2 3 4 5 6 7 8 9 from redis_om import ( Field , HashModel , ) class Customer ( HashModel ): first_name : str last_name : str = Field ( index = True ) In this example, we marked Customer.last_name as indexed. To create the indexes for any models that have indexed fields, use the migrate CLI command that Redis OM installs in your Python environment. This command detects any JsonModel or HashModel instances in your project and does the following for each model that isn't abstract or embedded: If no index exists yet for the model: The migrator creates an index The migrator stores a hash of the index definition If an index exists for the model: The migrator checks if the stored hash for the index is out of date If the stored hash is out of date, the migrator drops the index (not your data!) and rebuilds it with the new index definition You can also run the Migrator yourself with code: 1 2 3 4 5 6 7 from redis_om import ( get_redis_connection , Migrator ) redis = get_redis_connection () Migrator () . run ()","title":"Marking a Field as Indexed"},{"location":"redis_modules/","text":"Redis Modules \u00b6 Some advanced features of Redis OM, like rich query expressions and saving data as JSON, rely on core features from two source available Redis modules: RediSearch and RedisJSON . These modules are the \"magic\" behind the scenes: RediSearch adds querying, indexing, and full-text search to Redis RedisJSON adds the JSON data type to Redis Why this is important \u00b6 Without RediSearch or RedisJSON installed, you can still use Redis OM to create declarative models backed by Redis. We'll store your model data in Redis as Hashes, and you can retrieve models using their primary keys. You'll also get all the validation features from Pydantic. So, what won't work without these modules? Without RedisJSON, you won't be able to nest models inside each other, like we did with the example model of a Customer model that has an Address embedded inside it. Without RediSearch, you won't be able to use our expressive queries to find models -- just primary keys. So how do you get RediSearch and RedisJSON? \u00b6 You can use RediSearch and RedisJSON with your self-hosted Redis deployment. Just follow the instructions on installing the binary versions of the modules in their Quick Start Guides: RedisJSON Quick Start - Running Binaries RediSearch Quick Start - Running Binaries NOTE : Both of these modules' Quick Start Guides also have instructions on how to run the modules in Redis with Docker. Don't want to run Redis yourself? RediSearch and RedisJSON are also available on Redis Cloud. Get started here.","title":"Modules"},{"location":"redis_modules/#redis-modules","text":"Some advanced features of Redis OM, like rich query expressions and saving data as JSON, rely on core features from two source available Redis modules: RediSearch and RedisJSON . These modules are the \"magic\" behind the scenes: RediSearch adds querying, indexing, and full-text search to Redis RedisJSON adds the JSON data type to Redis","title":"Redis Modules"},{"location":"redis_modules/#why-this-is-important","text":"Without RediSearch or RedisJSON installed, you can still use Redis OM to create declarative models backed by Redis. We'll store your model data in Redis as Hashes, and you can retrieve models using their primary keys. You'll also get all the validation features from Pydantic. So, what won't work without these modules? Without RedisJSON, you won't be able to nest models inside each other, like we did with the example model of a Customer model that has an Address embedded inside it. Without RediSearch, you won't be able to use our expressive queries to find models -- just primary keys.","title":"Why this is important"},{"location":"redis_modules/#so-how-do-you-get-redisearch-and-redisjson","text":"You can use RediSearch and RedisJSON with your self-hosted Redis deployment. Just follow the instructions on installing the binary versions of the modules in their Quick Start Guides: RedisJSON Quick Start - Running Binaries RediSearch Quick Start - Running Binaries NOTE : Both of these modules' Quick Start Guides also have instructions on how to run the modules in Redis with Docker. Don't want to run Redis yourself? RediSearch and RedisJSON are also available on Redis Cloud. Get started here.","title":"So how do you get RediSearch and RedisJSON?"},{"location":"validation/","text":"Validation \u00b6 Redis OM uses Pydantic behind the scenes to validate data at runtime, based on the model's type annotations. Basic Type Validation \u00b6 Validation works for basic type annotations like str . Thus, given the following model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] ... Redis OM will ensure that first_name is always a string. But every Redis OM model is also a Pydantic model, so you can use existing Pydantic validators like EmailStr , Pattern , and many more for complex validation! Complex Validation \u00b6 Let's see what happens if we try to create a Customer object with an invalid email address. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] # We'll get a validation error if we try to use an invalid email address! try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"Not an email address!\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" As you can see, creating the Customer object generated the following error: 1 2 3 4 Traceback: pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) We'll also get a validation error if we change a field on a model instance to an invalid value and then try to save the model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) andrew . email = \"Not valid\" try : andrew . save () except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" Once again, we get the validation error: 1 2 3 4 Traceback: pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) Constrained Values \u00b6 If you want to use any of the constr Pydantic includes many type annotations to introduce constraints to your model field values. The concept of \"constraints\" includes quite a few possibilities: Strings that are always lowercase Strings that must match a regular expression Integers within a range Integers that are a specific multiple And many more... All of these constraint types work with Redis OM models. Read the Pydantic documentation on constrained types to learn more.","title":"Validation"},{"location":"validation/#validation","text":"Redis OM uses Pydantic behind the scenes to validate data at runtime, based on the model's type annotations.","title":"Validation"},{"location":"validation/#basic-type-validation","text":"Validation works for basic type annotations like str . Thus, given the following model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime from typing import Optional from pydantic import EmailStr from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] ... Redis OM will ensure that first_name is always a string. But every Redis OM model is also a Pydantic model, so you can use existing Pydantic validators like EmailStr , Pattern , and many more for complex validation!","title":"Basic Type Validation"},{"location":"validation/#complex-validation","text":"Let's see what happens if we try to create a Customer object with an invalid email address. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] # We'll get a validation error if we try to use an invalid email address! try : Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"Not an email address!\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" As you can see, creating the Customer object generated the following error: 1 2 3 4 Traceback: pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) We'll also get a validation error if we change a field on a model instance to an invalid value and then try to save the model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import datetime from typing import Optional from pydantic import EmailStr , ValidationError from redis_om import HashModel class Customer ( HashModel ): first_name : str last_name : str email : EmailStr join_date : datetime . date age : int bio : Optional [ str ] andrew = Customer ( first_name = \"Andrew\" , last_name = \"Brookins\" , email = \"andrew.brookins@example.com\" , join_date = datetime . date . today (), age = 38 , bio = \"Python developer, works at Redis, Inc.\" ) andrew . email = \"Not valid\" try : andrew . save () except ValidationError as e : print ( e ) \"\"\" pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email) \"\"\" Once again, we get the validation error: 1 2 3 4 Traceback: pydantic.error_wrappers.ValidationError: 1 validation error for Customer email value is not a valid email address (type=value_error.email)","title":"Complex Validation"},{"location":"validation/#constrained-values","text":"If you want to use any of the constr Pydantic includes many type annotations to introduce constraints to your model field values. The concept of \"constraints\" includes quite a few possibilities: Strings that are always lowercase Strings that must match a regular expression Integers within a range Integers that are a specific multiple And many more... All of these constraint types work with Redis OM models. Read the Pydantic documentation on constrained types to learn more.","title":"Constrained Values"}]}